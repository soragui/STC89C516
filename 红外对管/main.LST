C51 COMPILER V8.05a   MAIN                                                                 06/06/2013 12:19:55 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /***************************************************************************************************    
   2          工程名称：      IFR_1602
   3          功能描述：  按下遥控器上的任意按键，实现红外遥控器解码，1602液晶显示解码结果。
   4          硬件连接：  用1位杜邦线将J9_2与J5_IFR连接,将1602液晶接口对应插接到P4接口。
   5          维护记录：  2011-8-22
   6          ***************************************************************************************************/
   7          #include "reg51.h"          //包含头文件
   8          #define uchar unsigned char
   9          #define uint  unsigned int
  10          
  11          extern uchar Read_AD(uchar chn);
  12          extern show();
  13          extern InitLCD();
  14          
  15          sbit IFR_in=P3^2;                     //红外触发外部中断管脚
  16          
  17          char code Tab[16]="0123456789ABCDEF"; //1602液晶显示0-F的编码
  18          uchar dis2[16];                       //解码结果
  19          uchar  IRQ_num;                       //定时中断进入次数,用判断高低电平的计时
  20          uchar  T_num[33];
  21          bit IRF_ok;                           //解码1次完成标志位
  22          bit irpro_ok,IRF_ok;
  23          unsigned char decode[4];
  24          
  25          
  26          //**************************************************************************************************
  27          //延时函数
  28          //**************************************************************************************************
  29          delay(uint time)         //int型数据为16位,所以最大值为65535            
  30           {
  31   1        uint  i,j;             //定义变量i,j,用于循环语句 
  32   1        for(i=0;i<time;i++)    //for循环,循环50*time次
  33   1           for(j=0;j<100;j++); //for循环,循环50次
  34   1       }
  35          //**************************************************************************************************
  36          //定时中断0处理函数
  37          //**************************************************************************************************
  38          void IRQ_timer0(void) interrupt 1 using 1
  39          {
  40   1        IRQ_num++;   //计数1个周期时间，即2个下降沿之间的时间
  41   1      }
  42          
  43          //**************************************************************************************************
  44          //外部中断0处理函数
  45          //**************************************************************************************************
  46          void IRQ_EX0(void) interrupt 0 
  47          {
  48   1        static uchar  i;         //接收红外信号处理
  49   1        static bit flag;         //第二次进入中断时，完成第1个周期计时
  50   1      if(flag)                         
  51   1         {
  52   2          if(IRQ_num<63&&IRQ_num>=33)//按下一次按键，先来一个13.5ms(9ms+4.5ms)引导码
  53   2                              i=0;   //数组重新开始存储接下来的32位数的周期长度
  54   2                      T_num[i]=IRQ_num;  //存储每个每个周期的持续时间，用来判断高低电平
  55   2                      IRQ_num=0;         //定时中断次数置0，以便开始计数下一个周期的持续时间
C51 COMPILER V8.05a   MAIN                                                                 06/06/2013 12:19:55 PAGE 2   

  56   2                      i++;               //i加1
  57   2                               if(i==33)
  58   2                              {
  59   3                                       IRF_ok=1;     //解码1次完成，置标志位
  60   3                                       i=0;          //数组重新开始存储接下来的32位数的周期长度
  61   3                                      }
  62   2                }
  63   1               else
  64   1                      {
  65   2                      IRQ_num=0;             //定时中断次数置0   
  66   2                      flag=1;                //第一次进入中断,置标志位
  67   2                      }
  68   1      }
  69          //**************************************************************************************************
  70          //定时0初始化
  71          //**************************************************************************************************
  72          void timer0_init(void)//定时器0初始化
  73          {
  74   1      
  75   1        TMOD=0x02; //定时器0工作方式2，自动装入时间常数的8位定时器/计数器
  76   1        TH0=0x00; 
  77   1        TL0=0x00;  //置初值,(256-0)x12/12000000=0.256ms
  78   1        ET0=1;     //开定时器0中断
  79   1        TR0=1;     //启动定时器0
  80   1      }
  81          //**************************************************************************************************
  82          //外部中断0初始化
  83          //**************************************************************************************************
  84          void EX0init(void)
  85          {
  86   1       IT0 = 1;   //指定外部中断0下降沿触发，INT0 (P3.2)
  87   1       EX0 = 1;   //使能外部中断
  88   1       EA = 1;    //开总中断
  89   1      }
  90          //**************************************************************************************************
  91          //32位二进制得4字节数据
  92          //**************************************************************************************************
  93          void bit_byte(void) 
  94          { 
  95   1        uchar i, j, k=1;
  96   1        uchar temp,value;
  97   1        for(i=0;i<4;i++)        //循环4次得4字节
  98   1           {
  99   2            for(j=1;j<=8;j++)   //循环取8位得1字节
 100   2               {
 101   3                value>>=1;      //左移1位,依次从低位到高位
 102   3                temp=T_num[k];  //由于第1个数据为引导码，舍去，所以从第2开即是提取后面的32位
 103   3                if(temp>7)      //大于7*0.256=1.8ms为1,周期1.125ms表示"0"；周期2.25ms表示"1"
 104   3                   value|=0x80; //为1则最高位赋1
 105   3                k++;            //k加1，准备提取下1位
 106   3               }
 107   2           decode[i]=value;     //获取到1字节
 108   2           value=0;             //清0，准备提取下1字节        
 109   2           } 
 110   1      }
 111          //**************************************************************************************************
 112          //码值处理函数
 113          //**************************************************************************************************
 114          void code_pro(void)
 115          {
 116   1             //处理16位用户码
 117   1             dis2[0] = Tab[decode[0]/16];   //取用户码第1字节的高4位
C51 COMPILER V8.05a   MAIN                                                                 06/06/2013 12:19:55 PAGE 3   

 118   1                 dis2[1] = Tab[decode[0]%16];   //取用户码第1字节的低4位
 119   1                 dis2[2] = Tab[decode[1]/16];   //取用户码第2字节的高4位
 120   1                 dis2[3] = Tab[decode[1]%16];   //取用户码第2字节的低4位
 121   1      
 122   1                 dis2[4] = '-';                 //符号
 123   1                 dis2[5] = '(';                 //符号
 124   1                 dis2[6] = Tab[decode[2]/16];   //处理数据码的高4位
 125   1                 dis2[7] = Tab[decode[2]&16];   //处理数据码的低4位
 126   1                 dis2[8] = '/';                 //符号
 127   1                 dis2[9] = Tab[decode[3]/16];   //处理数据反码的高4位,用于核对数据是否接收准确
 128   1                 dis2[10] = Tab[decode[3]%16];  //处理数据反码的低4位
 129   1                 dis2[11] =')';                 //符号
 130   1      }
 131          //**************************************************************************************************
 132          //主函数
 133          //**************************************************************************************************
 134          void main(void)
 135          {
 136   1               uchar ch;
 137   1               EX0init();            //初始化外部中断0
 138   1               timer0_init();        //初始化定时器0
 139   1               InitLCD();            //初始化液晶
 140   1      
 141   1       while(1)              //死循环
 142   1         {
 143   2          if(IRF_ok)         //接收完1次后处理
 144   2                {   
 145   3                 bit_byte();     //提取到32位数据
 146   3             code_pro();     //码值处理
 147   3             show();         //显示码值
 148   3                 ch = dis2[6] | dis2[7];
 149   3                 P1 = ch;
 150   3                 IRF_ok=0;       //清标志位
 151   3                }       
 152   2         }
 153   1      }
 154            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    269    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     55    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
